include <syscall.h>
include <file.h>
include <unistd.h>
include <mboxbuf.h>

resource fd[int32]: 0xffffffffffffffff, 0, 100
resource pid[int32]: 0, 0xffffffffffffffff

sys_exit(code intptr)
sys_wait(pid pid, store ptr[out, int32])
sys_exec(file ptr[in, filename], argv ptr[in, array[ptr[in, string]]], envp ptr[in, array[ptr[in, string]]])
sys_yield()
sys_sleep(time int32)
sys_kill(pid pid)
sys_gettime()
sys_getpid() pid
sys_brk(brk_store ptr[out, intptr])
sys_mmap(addr_store ptr[in, intptr], len int32, mmap_flags flags[mmap_flags])
sys_shmem(addr_store ptr[in, intptr], len int32, mmap_flags flags[mmap_flags])

mmap_flags = MMAP_WRITE, MMAP_STACK

sys_putc(c int32)
sys_pgdir() 

resource sem_t[int32]: 0, 1, 0xffffffffffffffff
sys_sem_init(value int32) sem_t
sys_sem_post(sem_id sem_t)
sys_sem_wait(sem_id sem_t, timeout int32)
sys_sem_free(sem_id sem_t)
sys_sem_get_value(sem_id sem_t, value_store intptr)

resource event_t[int32]: 0, 1, 0xffffffffffffffff
sys_send_event(pid pid, event event_t, timeout int32)
sys_recv_event(pid_store ptr[out, pid], event_store ptr[out, event_t], timeout int32)

resource box_t[int32]: 0, 1, 0xffffffffffffffff
sys_mbox_init(max_slots int32) box_t
sys_mbox_send(id box_t, buf ptr[in, mboxbuf], timeout int32)
sys_mbox_recv(id box_t, buf ptr[out, mboxbuf], timeout int32)
sys_mbox_free(id box_t)
sys_mbox_info(id box_t, info ptr[out, mboxinfo])

mboxinfo {
	slots int32
	max_slots int32
	inuse bool8
	has_sender bool8
	has_receiver bool8
}

mboxbuf {
	from int32
	len int32
	size int32
	data array[int8]
}

open(file ptr[in, filename], flags flags[open_flags]) fd

open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_FSYNC, O_ASYNC, O_CREAT, O_EXCL, O_NOCTTY, O_NONBLOCK, O_SYNC, O_TRUNC
